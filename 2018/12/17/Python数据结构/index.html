<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">





























  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Microsoft YaHei:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="序列类型Python中的序列类型可分为两种：容器序列与扁平序列。  容器序列：list、tuple 和 collections.deque 扁平序列：str、bytes、bytearray、memoryview 和 array.array  容器序列存放的是对象的引用，所以能存放不同类型的数据；扁平序列存放的是值而不是引用(一段连续的内存空间)，所以只能容纳一种类型  Python中的序列类型还能">
<meta name="keywords" content="Python,Model">
<meta property="og:type" content="article">
<meta property="og:title" content="Python数据结构">
<meta property="og:url" content="http://janine.github.io/2018/12/17/Python数据结构/index.html">
<meta property="og:site_name" content="Janine&#39;s Blog">
<meta property="og:description" content="序列类型Python中的序列类型可分为两种：容器序列与扁平序列。  容器序列：list、tuple 和 collections.deque 扁平序列：str、bytes、bytearray、memoryview 和 array.array  容器序列存放的是对象的引用，所以能存放不同类型的数据；扁平序列存放的是值而不是引用(一段连续的内存空间)，所以只能容纳一种类型  Python中的序列类型还能">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://janine.github.io/2018/12/17/Python数据结构/字节码.png">
<meta property="og:image" content="http://janine.github.io/2018/12/17/Python数据结构/从字典中取值的算法流程图.jpg">
<meta property="og:updated_time" content="2018-12-21T09:51:19.509Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python数据结构">
<meta name="twitter:description" content="序列类型Python中的序列类型可分为两种：容器序列与扁平序列。  容器序列：list、tuple 和 collections.deque 扁平序列：str、bytes、bytearray、memoryview 和 array.array  容器序列存放的是对象的引用，所以能存放不同类型的数据；扁平序列存放的是值而不是引用(一段连续的内存空间)，所以只能容纳一种类型  Python中的序列类型还能">
<meta name="twitter:image" content="http://janine.github.io/2018/12/17/Python数据结构/字节码.png">






  <link rel="canonical" href="http://janine.github.io/2018/12/17/Python数据结构/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Python数据结构 | Janine's Blog</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style type="text/css">
html hanla:after {
   content: " ";
   display: inline;
   font-family: Arial;
   font-size: 0.89em;
}

html code hanla,
html pre hanla,
html kbd hanla,
html samp hanla {
display: none;
}

html ol > hanla,
html ul > hanla {
display: none;
}
</style><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Janine's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Hello, World~</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://janine.github.io/2018/12/17/Python数据结构/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Janine">
      <meta itemprop="description" content="You are my sunshine.">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Janine's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Python数据结构

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-17 11:05:09" itemprop="dateCreated datePublished" datetime="2018-12-17T11:05:09+08:00">2018-12-17</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-21 17:51:19" itemprop="dateModified" datetime="2018-12-21T17:51:19+08:00">2018-12-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="序列类型"><a href="#序列类型" class="headerlink" title="序列类型"></a>序列类型</h1><p>Python中的序列类型可分为两种：容器序列与扁平序列。</p>
<ul>
<li>容器序列：list、tuple 和 collections.deque</li>
<li>扁平序列：str、bytes、bytearray、memoryview 和 array.array</li>
</ul>
<p>容器序列存放的是对象的引用，所以能存放不同类型的数据；扁平序列存放的是值而不是引用(一段连续的内存空间)，所以只能容纳一种类型</p>
<hr>
<p>Python中的序列类型还能按是否能被修改来被分类：</p>
<ul>
<li>可变序列：list、bytearray、array.array、collections.deque 和 memoryview。</li>
<li>不可变序列：tuple、str 和 bytes。</li>
</ul>
<h2 id="list-comprehension-amp-generator-expression"><a href="#list-comprehension-amp-generator-expression" class="headerlink" title="list comprehension &amp; generator expression"></a>list comprehension &amp; generator expression</h2><p>我们把列表推导(list comprehension)简称为listcomps，生成器式表达器(generator expression)则称为genexps。</p>
<p>listcomps<br>genexps</p>
<h3 id="关于变量泄露"><a href="#关于变量泄露" class="headerlink" title="关于变量泄露"></a>关于变量泄露</h3><p>Python 2.x中，listcomps、genexps等没有自己的局部作用域，下面这段控制台代码就会导致x的值被改变</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 2.7.6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">'my precious'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dummy = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'ABC'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="string">'C'</span></span><br></pre></td></tr></table></figure>
<h2 id="关于元组"><a href="#关于元组" class="headerlink" title="关于元组"></a>关于元组</h2><p>元组除了作为<strong>可变的列表</strong>而存在以外，还可以用于<strong>没有字段名的记录</strong>。</p>
<h3 id="元组拆包"><a href="#元组拆包" class="headerlink" title="元组拆包"></a>元组拆包</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面几组代码你都能得到想象中的结果</span></span><br><span class="line">b, a = a, b</span><br><span class="line"></span><br><span class="line">t = (<span class="number">20</span>, <span class="number">8</span>)</span><br><span class="line">quotient, remainder = divmod(*t)</span><br><span class="line"></span><br><span class="line">a, b, *rest = range(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个*放在任意位置都能得到你想要的结果</span></span><br><span class="line">a, *body, c, d = range(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h3 id="嵌套元组拆包"><a href="#嵌套元组拆包" class="headerlink" title="嵌套元组拆包"></a>嵌套元组拆包</h3><p>只要接受方的结构符合表达式本身的嵌套结构，Python就可以做出正确的回应=v=<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b, (c, d) = (<span class="number">1</span>, <span class="number">2</span>, (<span class="string">'🙃'</span>, <span class="string">'🙃🙃'</span>))</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在Python 3之前，元组可以作为形参放在函数声明中，然而Python 3不再支持这种格式（这个改变对函数调用者并没有影响，它改变的是某些函数的声明方式）。具体原因见<a href="https://www.python.org/dev/peps/pep-3113/" target="_blank" rel="noopener">PEP 3113</a></p>
</blockquote>
<h3 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h3><p>collections.namedtuple 是一个工厂函数，它可以用来构建一个带字段名的元组和一个有名字的类。<br>用 namedtuple 构建的类的实例所消耗的内存跟元组是一样的，因为字段名都被存在对应的类里面。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Doge = collections.namedtuple(<span class="string">'AD'</span>, <span class="string">'sweater pants shoes'</span>)</span><br><span class="line">dog = Doge(sweater=<span class="string">'sw'</span>, pants=<span class="string">'pa'</span>, shoes=<span class="string">'sh'</span>)</span><br><span class="line">print(dog)</span><br><span class="line"><span class="comment"># AD(sweater='sw', pants='pa', shoes='sh')</span></span><br><span class="line">print(Doge)</span><br><span class="line"><span class="comment"># &lt;class '__main__.AD'&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="作为不可变列表的元组"><a href="#作为不可变列表的元组" class="headerlink" title="作为不可变列表的元组"></a>作为不可变列表的元组</h3><table>
<thead>
<tr>
<th></th>
<th>列表</th>
<th>元组</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>s.__add__(s2)</td>
<td>•</td>
<td>•</td>
<td>s + s2，拼接</td>
</tr>
<tr>
<td>s.__iadd__(s2)</td>
<td>•</td>
<td></td>
<td>s += s2，就地拼接</td>
</tr>
<tr>
<td>s.append(e)</td>
<td>•</td>
<td></td>
<td>在尾部添加一个新元素</td>
</tr>
<tr>
<td>s.clear()</td>
<td>•</td>
<td></td>
<td>删除所有元素</td>
</tr>
<tr>
<td>s.__contains__(e)</td>
<td>•</td>
<td>•</td>
<td>s 是否包含 e</td>
</tr>
<tr>
<td>s.copy()</td>
<td>•</td>
<td></td>
<td>列表的浅复制</td>
</tr>
<tr>
<td>s.count(e)</td>
<td>•</td>
<td>•</td>
<td>e 在 s 中出现的次数</td>
</tr>
<tr>
<td>s.__delitem__(p)</td>
<td>•</td>
<td></td>
<td>把位于 p 的元素删除</td>
</tr>
<tr>
<td>s.extend(it)</td>
<td>•</td>
<td></td>
<td>把可迭代对象 it 追加给 s</td>
</tr>
<tr>
<td>s.__getitem__(p)</td>
<td>•</td>
<td>•</td>
<td>s[p]，获取位置 p 的元素</td>
</tr>
<tr>
<td>s.__getnewargs__()</td>
<td></td>
<td>•</td>
<td>在 pickle 中支持更加优化的序列化</td>
</tr>
<tr>
<td>s.index(e)</td>
<td>•</td>
<td>•</td>
<td>在 s 中找到元素 e 第一次出现的位置</td>
</tr>
<tr>
<td>s.insert(p, e)</td>
<td>•</td>
<td></td>
<td>在位置 p 之前插入元素e</td>
</tr>
<tr>
<td>s.__iter__()</td>
<td>•</td>
<td>•</td>
<td>获取 s 的迭代器</td>
</tr>
<tr>
<td>s.__len__()</td>
<td>•</td>
<td>•</td>
<td>len(s)，元素的数量</td>
</tr>
<tr>
<td>s.__mul__(n)</td>
<td>•</td>
<td>•</td>
<td>s * n，n 个 s 的重复拼接</td>
</tr>
<tr>
<td>s.__imul__(n)</td>
<td>•</td>
<td></td>
<td>s *= n，就地重复拼接</td>
</tr>
<tr>
<td>s.__rmul__(n)</td>
<td>•</td>
<td>•</td>
<td>n * s，反向拼接 *</td>
</tr>
<tr>
<td>s.pop([p])</td>
<td>•</td>
<td></td>
<td>删除最后或者是（可选的）位于 p 的元素，并返回它的值</td>
</tr>
<tr>
<td>s.remove(e)</td>
<td>•</td>
<td></td>
<td>删除 s 中的第一次出现的 e</td>
</tr>
<tr>
<td>s.reverse()</td>
<td>•</td>
<td></td>
<td>就地把 s 的元素倒序排列</td>
</tr>
<tr>
<td>s.__reversed__()</td>
<td>•</td>
<td></td>
<td>返回 s 的倒序迭代器</td>
</tr>
<tr>
<td>s.__setitem__(p, e)</td>
<td>•</td>
<td></td>
<td>s[p] = e，把元素 e 放在位置p，替代已经在那个位置的元素</td>
</tr>
<tr>
<td>s.sort([key], [reverse])</td>
<td>•</td>
<td></td>
<td>就地对 s 中的元素进行排序，可选的参数有键（key）和是否倒序（reverse）</td>
</tr>
</tbody>
</table>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>我们知道，切片操作的区间是左闭右开的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1表示步长，-号表示反向</span></span><br><span class="line">print(lst[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<h3 id="多维切片"><a href="#多维切片" class="headerlink" title="多维切片"></a>多维切片</h3><p>[] 运算符里还可以使用以逗号分开的多个索引/切片。要正确处理这种 [] 运算符的话，对象的特殊方法<code>__getitem__</code>和<code>__setitem__</code>需要以元组的形式来接收 <strong>a[i, j]</strong> 中的索引。也就是说，如果要得到 <strong>a[i, j]</strong> 的值，Python 会调用<code>a.__getitem__((i, j))</code>。</p>
<h3 id="省略"><a href="#省略" class="headerlink" title="省略"></a>省略</h3><blockquote>
<p>省略（ellipsis）的正确书写方法是三个英语句号（…），省略在 Python 解析器眼里是一个符号，而实际上它是 Ellipsis 对象的别名，而 Ellipsis 对象又是 ellipsis 类的单一实例(跟 bool 是小写，但是它的两个实例写作 True 和 False 相似)。</p>
</blockquote>
<p>省略可以用在函数参数列表中：<code>func(a, ..., z)</code><br>可以当做切片规范的一部分：<code>a[i:...]</code></p>
<h2 id="序列的-与"><a href="#序列的-与" class="headerlink" title="序列的 + 与 *"></a>序列的 + 与 *</h2><p>我们知道可以用<code>&#39;xixi&#39; * 3</code>来组成<code>&#39;xixixixixixi&#39;</code>这个字符串，通用可以把这种操作符重载使用在<code>lsit</code>等类型上，比如你想用<code>my_list = [[]] * 3</code>来初始化一个列表，但是我们<strong>得到的列表里包含的三个列表其实是三个引用，指向同一个列表</strong>，这可能与我们想象的不一致。<br>当我们想这样做时，最好的选择是使用列表推导：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">board = [[<span class="string">'_'</span>] * <span class="number">4</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">print(board)</span><br><span class="line"><span class="comment"># [['_', '_', '_', '_'], ['_', '_', '_', '_'], ['_', '_', '_', '_']]</span></span><br><span class="line"></span><br><span class="line">board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">'X'</span></span><br><span class="line">print(board)</span><br><span class="line"><span class="comment"># 拿到了我们想要的结果</span></span><br><span class="line"><span class="comment"># [['_', '_', '_', '_'], ['_', '_', 'X', '_'], ['_', '_', '_', '_']]</span></span><br></pre></td></tr></table></figure></p>
<p>下面这个方法看上去更简单，然而得到的结果与我们想象中不一样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">weird_board = [[<span class="string">'_'</span>] * <span class="number">3</span>] * <span class="number">3</span></span><br><span class="line">print(weird_board)</span><br><span class="line"><span class="comment"># [['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]</span></span><br><span class="line"></span><br><span class="line">weird_board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">'O'</span></span><br><span class="line">print(weird_board)</span><br><span class="line"><span class="comment"># [['_', '_', 'O'], ['_', '_', 'O'], ['_', '_', 'O']]</span></span><br></pre></td></tr></table></figure></p>
<p>事实上，上面这段代码犯的错误本质上跟下面的代码犯的错误一样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">row = [<span class="string">'_'</span>] * <span class="number">3</span></span><br><span class="line">board = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    board.append(row)</span><br></pre></td></tr></table></figure></p>
<h2 id="序列的-和"><a href="#序列的-和" class="headerlink" title="序列的 += 和 *="></a>序列的 += 和 *=</h2><p>+=和*=本质上差不多，这里简化讨论+=。<br>当我们使用+=操作符，Python背后会调用特殊方法<code>__iadd__</code>。同时对可变序列来说，变量会就地改动(比如调用extend方法等)，如果没有实现这个方法，就退一步调用<code>__add__</code>，效果就类似于<code>a = a + b</code>，产生一个新对象再赋值。所以说，在<code>a += b</code>这个表达式中，变量名会不会被关联到新的对象，取决于这个类型有没有实现<code>__iadd__</code>这个方法(事实上可变序列一般都实现了，不可变序列根本就不支持这个操作啦)。<br>对不可变序列进行重复拼接操作(改引用而已)的话，效率会很低，因为每次都会产生新的对象。</p>
<blockquote>
<p><strong>str</strong>是一个例外，因为对字符串做+=实在是太普遍了，所以CPython对它做了优化。为<strong>str</strong>初始化内存的时候，程序会为它留出额外的可扩展空间，因此进行增量操作的时候，并不会涉及复制原有字符串到新位置这类操作。</p>
</blockquote>
<p>一个很无聊的错误：<br>执行下面这段代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line">t[<span class="number">2</span>] += [<span class="number">50</span>, <span class="number">60</span>]</span><br></pre></td></tr></table></figure></p>
<p>会抛出异常<code>TypeError: &#39;tuple&#39; object does not support item assignment</code><br>这行代码(第2行)的本质分为两步</p>
<ol>
<li>new_list = [30, 40] += [50, 60]</li>
<li>t[2] = new_list</li>
</ol>
<p>程序是在第二步出错的，所以第一步会被执行，这个<code>t[2]</code>实际上是改变成我们想要的值的。<br>所以，大佬得到了三个教训：</p>
<ol>
<li>不要把可变对象放在元组里面。</li>
<li>增量赋值不是一个原子操作。我们刚才也看到了，它虽然抛出了异常，但还是完成了操作。</li>
<li>查看Python的字节码并不难，而且它对我们了解代码背后的运行机制很有帮助。</li>
</ol>
<h2 id="list-sort方法和内置函数sorted"><a href="#list-sort方法和内置函数sorted" class="headerlink" title="list.sort方法和内置函数sorted"></a>list.sort方法和内置函数sorted</h2><p>list.sort方法会就地排序列表，也就是说不会把原列表复制一份。这也是这个方法的返回值是None的原因，提醒你本方法不会新建一个列表。在这种情况下返回None其实是Python的一个惯例：如果一个函数或者方法对对象进行的是就地改动，那它就应该返回None，好让调用者知道传入的参数发生了变动，而且并未产生新的对象。<br>这样操作有一个缺点，无法链式调用，形成<a href="https://en.wikipedia.org/wiki/Fluent_interface" target="_blank" rel="noopener">fluent interface</a></p>
<blockquote>
<p>In Python returning <code>self</code> in the instance method is one way to implement the fluent pattern.</p>
</blockquote>
<p>与list.sort相反的是，内置函数sorted会新建一个列表作为返回值。</p>
<h2 id="当列表不是首选项"><a href="#当列表不是首选项" class="headerlink" title="当列表不是首选项"></a>当列表不是首选项</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>创建数组需要一个类型码，这个类型码用来表示在底层的C语言应该存放怎样的数据类型。</p>
<p>列表和数组中的基本操作：</p>
<table>
<thead>
<tr>
<th></th>
<th>列表</th>
<th>数组</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>s.__add(s2)__</td>
<td>•</td>
<td>•</td>
<td>s + s2，拼接</td>
</tr>
<tr>
<td>s.__iadd(s2)__</td>
<td>•</td>
<td>•</td>
<td>s += s2，就地拼接</td>
</tr>
<tr>
<td>s.append(e)</td>
<td>•</td>
<td>•</td>
<td>在尾部添加一个元素</td>
</tr>
<tr>
<td>s.byteswap</td>
<td></td>
<td>•</td>
<td>翻转数组内每个元素的字节序列，转换字节序</td>
</tr>
<tr>
<td>s.clear()</td>
<td>•</td>
<td></td>
<td>删除所有元素</td>
</tr>
<tr>
<td>s.__contains__(e)</td>
<td>•</td>
<td>•</td>
<td>s 是否含有 e</td>
</tr>
<tr>
<td>s.copy()</td>
<td>•</td>
<td></td>
<td>对列表浅复制</td>
</tr>
<tr>
<td>s.__copy__()</td>
<td></td>
<td>•</td>
<td>对 copy.copy 的支持</td>
</tr>
<tr>
<td>s.count(e)</td>
<td>•</td>
<td>•</td>
<td>s 中 e 出现的次数</td>
</tr>
<tr>
<td>s.__deepcopy__()</td>
<td></td>
<td>•</td>
<td>对 copy.deepcopy 的支持</td>
</tr>
<tr>
<td>s.__delitem__(p)</td>
<td>•</td>
<td>•</td>
<td>删除位置 p 的元素</td>
</tr>
<tr>
<td>s.extend(it)</td>
<td>•</td>
<td>•</td>
<td>将可迭代对象 it 里的元素添加到尾部</td>
</tr>
<tr>
<td>s.frombytes(b)</td>
<td></td>
<td>•</td>
<td>将压缩成机器值的字节序列读出来添加到尾部</td>
</tr>
<tr>
<td>s.fromfile(f, n)</td>
<td></td>
<td>•</td>
<td>将二进制文件 f 内含有机器值读出来添加到尾部，最多添加 n 项</td>
</tr>
<tr>
<td>s.fromlist(l)</td>
<td></td>
<td>•</td>
<td>将列表里的元素添加到尾部，如果其中任何一个元素导致了 TypeError 异常，那么所有的添加都会取消</td>
</tr>
<tr>
<td>s.__getitem__(p)</td>
<td>•</td>
<td>•</td>
<td>s[p]，读取位置 p 的元素</td>
</tr>
<tr>
<td>s.index(e)</td>
<td>•</td>
<td>•</td>
<td>找到 e 在序列中第一次出现的位置</td>
</tr>
<tr>
<td>s.insert(p, e)</td>
<td>•</td>
<td>•</td>
<td>在位于 p 的元素之前插入元素 e</td>
</tr>
<tr>
<td>s.itemsize</td>
<td></td>
<td>•</td>
<td>数组中每个元素的长度是几个字节</td>
</tr>
</tbody>
</table>
<p>从Python 3.4开始，数组类型不再支持list.sort()这种原地排序方法，要排序就得用sorted()函数新建数组：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = array.array(a.typecode, sorted(a))</span><br></pre></td></tr></table></figure></p>
<h3 id="memoryview"><a href="#memoryview" class="headerlink" title="memoryview"></a>memoryview</h3><blockquote>
<p><a href="https://stackoverflow.com/questions/4845418/when-should-a-memoryview-be-used/" target="_blank" rel="noopener">memoryview</a>其实是泛化和去数学化的NumPy数组。它让你在不需要复制内容的前提下，在数据结构之间共享内存。其中数据结构可以是任何形式，比如PIL图片、SQLite数据库和NumPy的数组，等等。这个功能在处理大型数据集合的时候非常重要。</p>
</blockquote>
<p>memoryview.cast的概念与数组模块类似，能用不同的方式读写一块内存块，并且不会移动里面的内容字节</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="collections-deque"><a href="#collections-deque" class="headerlink" title="collections.deque"></a>collections.deque</h3><p>我们可以在操作上把列表当队列来用，但是部分操作(比如删除/添加列表的第一个元素)非常耗时(涉及移动列表的所有元素)。<br>collections.deque类（双向队列）是一个线程安全、快速从两端添加/删除元素的数据类型。</p>
<blockquote>
<p>append和popleft都是原子操作，也就说是deque可以在多线程程序中安全地当作先进先出的栈使用，而使用者不需要担心资源锁的问题.</p>
</blockquote>
<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>提供了同步（线程安全）类Queue、LifoQueue和PriorityQueue，不同的线程可以利用这些数据类型来交换信息。这三个类的构造方法都有一个可选参数maxsize，它接收正整数作为输入值，用来限定队列的大小。但是在满员的时候，这些类不会扔掉旧的元素来腾出位置。相反，如果队列满了，它就会被锁住，直到另外的线程移除了某个元素而腾出了位置。这一特性让这些类很适合用来<strong>控制活跃线程的数量</strong>。</p>
<h3 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h3><p>这个包实现了自己的 Queue，它跟 queue.Queue 类似，是设计给进程间通信用的。同时还有一个专门的 multiprocessing.JoinableQueue 类型，可以让任务管理变得更方便。</p>
<h3 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h3><p>Python 3.4新提供的包，里面有Queue、LifoQueue、PriorityQueue和JoinableQueue，这些类受到queue和multiprocessing模块的影响，但是为异步编程里的任务管理提供了专门的便利。</p>
<h3 id="heapq"><a href="#heapq" class="headerlink" title="heapq"></a>heapq</h3><p>跟上面三个模块不同的是，heapq没有队列类，而是提供了heappush和 heappop方法，让用户可以把可变序列当作堆队列或者优先队列来使用。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Python 序列类型最常见的分类就是可变和不可变序列。但另外一种分类方式也很有用，那就是把它们分为扁平序列和容器序列。前者的体积更小、速度更快而且用起来更简单，但是它只能保存一些原子性的数据，比如数字、字符和字节。容器序列则比较灵活，但是当容器序列遇到可变对象时，用户就需要格外小心了，因为这种组合时常会搞出一些“意外”，特别是带嵌套的数据结构出现时，用户要多费一些心思来保证代码的正确。</p>
<p>列表推导和生成器表达式则提供了灵活构建和初始化序列的方式，这两个工具都异常强大。如果你还不能熟练地使用它们，可以专门花时间练习一下。它们其实不难，而且用起来让人上瘾。</p>
<p>元组在 Python 里扮演了两个角色，它既可以用作无名称的字段的记录，又可以看作不可变的列表。当元组被当作记录来用的时候，拆包是最安全可靠地从元组里提取不同字段信息的方式。新引入的 * 句法让元组拆包的便利性更上一层楼，让用户可以选择性忽略不需要的字段。具名元组也已经不是一个新概念了，但它似乎没有受到应有的重视。就像普通元组一样，具名元组的实例也很节省空间，但它同时提供了方便地通过名字来获取元组各个字段信息的方式，另外还有个实用的 ._asdict() 方法来把记录变成 OrderedDict 类型。</p>
<p>Python 里最受欢迎的一个语言特性就是序列切片，而且很多人其实还没完全了解它的强大之处。比如，用户自定义的序列类型也可以选择支持 NumPy 中的多维切片和省略（…）。另外，对切片赋值是一个修改可变序列的捷径。</p>
<p>重复拼接 seq <em> n 在正确使用的前提下，能让我们方便地初始化含有不可变元素的多维列表。增量赋值 += 和 </em>= 会区别对待可变和不可变序列。在遇到不可变序列时，这两个操作会在背后生成新的序列。但如果被赋值的对象是可变的，那么这个序列会就地修改——然而这也取决于序列本身对特殊方法的实现。</p>
<p>序列的 sort 方法和内置的 sorted 函数虽然很灵活，但是用起来都不难。这两个方法都比较灵活，是因为它们都接受一个函数作为可选参数来指定排序算法如何比较大小，这个参数就是 key 参数。key 还可以被用在 min 和 max 函数里。如果在插入新元素的同时还想保持有序序列的顺序，那么需要用到 bisect.insort。bisect.bisect 的作用则是快速查找。</p>
<p>除了列表和元组，Python 标准库里还有 array.array。另外，虽然 NumPy 和 SciPy 都不是 Python 标准库的一部分，但稍微学习一下它们，会让你在处理大规模数值型数据时如有神助。</p>
<blockquote>
<p>Python 入门教材往往会强调列表是可以同时容纳不同类型的元素的，但是实际上这样做并没有什么特别的好处。我们之所以用列表来存放东西，是期待在稍后使用它的时候，其中的元素有一些通用的特性（比如，列表里存的是一类可以“呱呱”叫的动物，那么所有的元素都应该会发出这种叫声，即便其中一部分元素类型并不是鸭子）。<br>元组则恰恰相反，它经常用来存放不同类型的的元素。这也符合它的本质，元组就是用作存放彼此之间没有关系的数据的记录。</p>
</blockquote>
<h1 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h1><p>标准库中的所有映射类型都是利用dict实现的，因此它们有个共同的限制，即只有<code>可散列的(hashable)</code>数据类型才能用作这些映射里的键。</p>
<blockquote>
<p>如果一个对象是hashable的，那么在这个对象的生命周期中，它的散列值是不变的，而且这个对象需要实现__hash__() 方法。另外hashable对象还要有__qe__() 方法，这样才能跟其他键做比较。如果两个hashable对象是相等的，那么它们的散列值一定是一样的。</p>
</blockquote>
<p>原子不可变数据类型（str、bytes 和数值类型）都是hashable类型，frozenset 也是hashable的，因为根据其定义，frozenset里只能容纳hashable类型。元组的话，只有当一个元组包含的所有元素都是hashable类型的情况下，它才是hashable的。</p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="字典创建的不同方式"><a href="#字典创建的不同方式" class="headerlink" title="字典创建的不同方式"></a>字典创建的不同方式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = dict(one=<span class="number">1</span>, two=<span class="number">2</span>, three=<span class="number">3</span>)</span><br><span class="line">b = &#123;<span class="string">'one'</span>: <span class="number">1</span>, <span class="string">'two'</span>: <span class="number">2</span>, <span class="string">'three'</span>: <span class="number">3</span>&#125;</span><br><span class="line">c = dict(zip([<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">d = dict([(<span class="string">'two'</span>, <span class="number">2</span>), (<span class="string">'one'</span>, <span class="number">1</span>), (<span class="string">'three'</span>, <span class="number">3</span>)])</span><br><span class="line">e = dict(&#123;<span class="string">'three'</span>: <span class="number">3</span>, <span class="string">'one'</span>: <span class="number">1</span>, <span class="string">'two'</span>: <span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>除了以上方式外，还有字典推导(dict comprehension)可用以构造新字典。</p>
<h3 id="字典推导"><a href="#字典推导" class="headerlink" title="字典推导"></a>字典推导</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DIAL_CODES = [</span><br><span class="line">    (<span class="number">86</span>, <span class="string">'China'</span>),</span><br><span class="line">    (<span class="number">91</span>, <span class="string">'India'</span>),</span><br><span class="line">    (<span class="number">1</span>, <span class="string">'United States'</span>),</span><br><span class="line">    (<span class="number">62</span>, <span class="string">'Indonesia'</span>),</span><br><span class="line">    (<span class="number">55</span>, <span class="string">'Brazil'</span>),</span><br><span class="line">    (<span class="number">92</span>, <span class="string">'Pakistan'</span>),</span><br><span class="line">    (<span class="number">880</span>, <span class="string">'Bangladesh'</span>),</span><br><span class="line">    (<span class="number">234</span>, <span class="string">'Nigeria'</span>),</span><br><span class="line">    (<span class="number">7</span>, <span class="string">'Russia'</span>),</span><br><span class="line">    (<span class="number">81</span>, <span class="string">'Japan'</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">dial_dict = &#123;country:code <span class="keyword">for</span> code,country <span class="keyword">in</span> DIAL_CODES&#125;</span><br><span class="line">print(dial_dict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># result:</span></span><br><span class="line"><span class="comment"># &#123;'China': 86, 'India': 91, 'United States': 1, 'Indonesia': 62, 'Brazil': 55, 'Pakistan': 92, 'Bangladesh': 880, 'Nigeria': 234, 'Russia': 7, 'Japan': 81&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="常见的映射方法"><a href="#常见的映射方法" class="headerlink" title="常见的映射方法"></a>常见的映射方法</h2><p>下面为dict、collections.defaultdict和collections.OrderedDict这三种映射类型的方法列表，可选参数以[…]表示：</p>
<table>
<thead>
<tr>
<th></th>
<th>dict</th>
<th>defaultdict</th>
<th>OrderedDict</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>d.clear()</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>移除所有元素</td>
</tr>
<tr>
<td>d.__contains__(k)</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>检查 k 是否在 d 中</td>
</tr>
<tr>
<td>d.copy()</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>浅复制</td>
</tr>
<tr>
<td>d.__copy__()</td>
<td></td>
<td>•</td>
<td></td>
<td>用于支持 copy.copy</td>
</tr>
<tr>
<td>d.default_factory</td>
<td></td>
<td>•</td>
<td></td>
<td>在 __missing__ 函数中被调用的函数，用以给未找到的  元素设置值*</td>
</tr>
<tr>
<td>d.__delitem__(k)</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>del d[k]，移除键为 k 的元素</td>
</tr>
<tr>
<td>d.fromkeys(it,  [initial])</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>将迭代器 it 里的元素设置为映射里的键，如果有  initial 参数，就把它作为这些键对应的值（默认是  None）</td>
</tr>
<tr>
<td>d.get(k,  [default])</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>返回键 k 对应的值，如果字典里没有键 k，则返回 None  或者 default</td>
</tr>
<tr>
<td>d.__getitem__(k)</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>让字典 d 能用 d[k] 的形式返回键 k 对应的值</td>
</tr>
<tr>
<td>d.items()</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>返回 d 里所有的键值对</td>
</tr>
<tr>
<td>d.__iter__()</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>获取键的迭代器</td>
</tr>
<tr>
<td>d.keys()</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>获取所有的键</td>
</tr>
<tr>
<td>d.__len__()</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>可以用 len(d) 的形式得到字典里键值对的数量</td>
</tr>
<tr>
<td>d.__missing__(k)</td>
<td></td>
<td>•</td>
<td></td>
<td>当 __getitem__ 找不到对应键的时候，这个方法会被调  用</td>
</tr>
<tr>
<td>d.move_to_end(k,  [last])</td>
<td></td>
<td></td>
<td>•</td>
<td>把键为 k 的元素移动到最靠前或者最靠后的位置（last  的默认值是 True）</td>
</tr>
<tr>
<td>d.pop(k, [defaul]</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>返回键 k 所对应的值，然后移除这个键值对。如果没  有这个键，返回 None 或者 defaul</td>
</tr>
<tr>
<td>d.popitem()</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>随机返回一个键值对并从字典里移除它#</td>
</tr>
<tr>
<td>d.__reversed__()</td>
<td></td>
<td></td>
<td>•</td>
<td>返回倒序的键的迭代器</td>
</tr>
<tr>
<td>d.setdefault(k,  [default])</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>若字典里有键k，则把它对应的值设置为 default，然  后返回这个值；若无，则让 d[k] = default，然后返回  default</td>
</tr>
<tr>
<td>d.__setitem__(k,  v)</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>实现 d[k] = v 操作，把 k 对应的值设为v</td>
</tr>
<tr>
<td>d.update(m,  [**kargs])</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>m 可以是映射或者键值对迭代器，用来更新 d 里对应的  条目</td>
</tr>
<tr>
<td>d.values()</td>
<td>•</td>
<td>•</td>
<td>•</td>
<td>返回字典里的所有值</td>
</tr>
</tbody>
</table>
<div class="note info"><p>default_factory并不是一个方法，而是一个可调用对象（callable），它的值在defaultdict初始化的时候由用户设定。</p></div>
<div class="note info"><p>OrderedDict.popitem()会移除字典里最先插入的元素（先进先出）；同时这个方法还有一个可选的last参数，若为真，则会移除最后插入的元素（后进先出）。</p></div>
<h2 id="更新值时找不到键的问题"><a href="#更新值时找不到键的问题" class="headerlink" title="更新值时找不到键的问题"></a>更新值时找不到键的问题</h2><p>一般我们会用 <code>adict[key] = value</code> 为<span class="label info">key</span>对应的值直接赋值，Python内部会调用方法先找到这个键，如果没有找到就会抛出异常。虽然我们可以用 <code>d.get(k, default)</code> 来代替上面那种方式，给找不到的键一个<span class="label info">默认值</span>，但是要<span class="label success">更新某个键对应的值</span>的时候，不管是使用 <code>__getitem__</code> 还是 <code>get</code> 都会不自然，而且效率低。</p>
<h3 id="一种解决方案–setdefault"><a href="#一种解决方案–setdefault" class="headerlink" title="一种解决方案–setdefault"></a>一种解决方案–setdefault</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re, sys, collections</span><br><span class="line"></span><br><span class="line">result = &#123;&#125;</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"res/song.txt"</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    WORD_RE = re.compile(<span class="string">r'\w+'</span>)</span><br><span class="line">    <span class="keyword">for</span> line_no, line <span class="keyword">in</span> enumerate(file, start=<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> watch <span class="keyword">in</span> WORD_RE.finditer(line):</span><br><span class="line">            word = watch.group()</span><br><span class="line">            column_no = watch.start() + <span class="number">1</span></span><br><span class="line">            location = (line_no, column_no)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 提取word出现的情况，如果没有就返回[]</span></span><br><span class="line">            <span class="comment"># 这是一种很差的实现</span></span><br><span class="line">            <span class="comment"># cup = result.get(word, [])</span></span><br><span class="line">            <span class="comment"># cup.append(location)</span></span><br><span class="line">            <span class="comment"># result[word] = cup</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 一种比较好的实现</span></span><br><span class="line">            result.setdefault(word, []).append(location)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> sorted(result, key=str.upper):</span><br><span class="line">    print(word, result[word])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_dict.setdefault(key, []).append(new_value)</span><br></pre></td></tr></table></figure>
<p>与<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> my_dict:</span><br><span class="line">    my_dict[key] = []</span><br><span class="line">my_dict[key].append(new_value)</span><br></pre></td></tr></table></figure></p>
<p>的效果是一致的，但是后者至少要进行两次键查询(如果键不存在就是三次)，前者只需要一次就可以完成整个操作。</p>
<h2 id="读取映射里不存在的键得到默认值的问题"><a href="#读取映射里不存在的键得到默认值的问题" class="headerlink" title="读取映射里不存在的键得到默认值的问题"></a>读取映射里不存在的键得到默认值的问题</h2><p>这个问题有如下两种解决方案</p>
<h3 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h3><p>第一种是，用<span class="label success">collections.defaultdict</span>代替默认的<span class="label info">dict</span>.<br>在实例化一个 <strong>defaultdict</strong> 的时候，需要给构造方法提供一个可调用对象，这个可调用对象会在 <strong>__getitem__</strong> 碰到找不到的键的时候被调用，让 <strong>__getitem__</strong> 返回某种默认值。</p>
<blockquote>
<p>有一个这样的字典： <code>adict = collections.defaultdict(list)</code> 如果表达式 <code>adict[&#39;unknown-key&#39;]</code> 找不到这个键，会调用 <code>list()</code> 来建立一个新列表，把这个新列表作为值，<span class="label success">'unknown-key'</span> 作为它的键，放到 <span class="label success">adict</span> 中，而后返回这个新列表的引用。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不用 dict 类型</span></span><br><span class="line"><span class="comment"># 创建 defaultdict 对象的时候，就需要给它配置一个为找不到的键创造默认值的方法</span></span><br><span class="line">result = collections.defaultdict(list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接append即可</span></span><br><span class="line">result[word].append(location)</span><br></pre></td></tr></table></figure>
<p>这一切背后其实是特殊方法 <code>\__missing\__</code> , 它会在 defaultdict 遇到找不到的键的时候调用 <strong>default_factory</strong> ，而实际上这个特性是所有映射类型都可以选择去支持的。</p>
<h3 id="missing"><a href="#missing" class="headerlink" title="__missing__"></a>__missing__</h3><p>第二种是，<span class="label success">定义一个dict的子类，然后在子类中实现 \__missing\__ 方法</span>。</p>
<div class="note success"><p>所有的映射类型在处理找不到的键的时候，都会牵扯到 <span class="label primary">__missing__</span> 方法。虽然基类 <code>dict</code> 没有定义这个方法，但是它是知道有这个方法的存在的。所以如果有一个类继承了 <code>dict</code> ，然后这个子类提供了 <span class="label primary">__missing__</span> 方法，那么在 <strong>__getitem__</strong> 遇到找不到的键时，Python 就会自动调用它，而不是抛出 KeyError 异常。</p></div>
<div class="note danger"><p>如果要自定义一个映射类型，更合适的策略其实是继承 <code>collections.UserDict</code> 类</p></div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myDict</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self[str(key) <span class="keyword">if</span> <span class="keyword">not</span> isinstance(key, str) <span class="keyword">else</span> <span class="keyword">None</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">origin = myDict(&#123;<span class="string">"2"</span>: <span class="number">2</span>, <span class="string">'3'</span>:<span class="number">3</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询时把非字符串的key转化为字符串</span></span><br><span class="line">print(origin[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<h2 id="其他映射类型"><a href="#其他映射类型" class="headerlink" title="其他映射类型"></a>其他映射类型</h2><ul>
<li>collections.OrderedDict<ul>
<li>这个类型在添加键的时候会保持顺序</li>
</ul>
</li>
<li>collections.ChainMap<ul>
<li>这个类型可以容纳多个不同的映射对象，查找时每个对象的key都会被逐个查找</li>
</ul>
</li>
<li>collections.Counter<ul>
<li>这个类型会给键准备一个整数计数器，每次更新都会增加。也可以当做 <code>多重集合(集合里的元素可以出现不止一次)</code> 来用。</li>
</ul>
</li>
<li>colllections.UserDict<ul>
<li>这个类就是把标准dict用纯Python实现了一边，专门用来给用户继承写子类</li>
</ul>
</li>
</ul>
<h3 id="编写-UserDict-的子类"><a href="#编写-UserDict-的子类" class="headerlink" title="编写 UserDict 的子类"></a>编写 UserDict 的子类</h3><blockquote>
<p>更倾向于从 UserDict 而不是从 dict 继承的主要原因是，后者有时会在某些方法的实现上走一些捷径，导致我们不得不在它的子类中重写这些方法，但是 UserDict 就不会带来这些问题。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrKeyDict</span><span class="params">(collections.UserDict)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(key, str):</span><br><span class="line">            <span class="keyword">raise</span> KeyError(key)</span><br><span class="line">        <span class="keyword">return</span> self[str(key)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(key) <span class="keyword">in</span> self.data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, item)</span>:</span></span><br><span class="line">        self.data[str(key)] = item</span><br></pre></td></tr></table></figure>
<h2 id="不可变映射类型"><a href="#不可变映射类型" class="headerlink" title="不可变映射类型"></a>不可变映射类型</h2><p><code>types.MappingProxyType</code> ：<br>如果给这个类一个映射，它会返回一个只读的映射视图。虽然是个只读视图，但是它是动态的。这意味着如果对原映射做出了改动，我们通过这个视图可以观察到，但是无法通过这个视图对原映射做出修改。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合中的元素必须是 <span class="label success">hashable</span> 的，set类型本身是不可hash的，但是frozenset可以。<br>{1, 2, 3} 这种字面量句法相比于构造方法（<code>set([1, 2, 3])</code>）要更快，因为后者要先从set这个名字来查询构造方法，然后新建一个列表，最后把列表传到构造方法里，但是如果是像 <strong>{1, 2, 3}</strong> 这样的字面量，Python 会利用一个专门的叫作 <code>BUILD_SET</code> 的字节码来创建集合。</p>
<img src="/2018/12/17/Python数据结构/字节码.png" title="字节码">
<h2 id="dict-和-set-的背后"><a href="#dict-和-set-的背后" class="headerlink" title="dict 和 set 的背后"></a>dict 和 set 的背后</h2><h3 id="dict-中的散列表"><a href="#dict-中的散列表" class="headerlink" title="dict 中的散列表"></a>dict 中的散列表</h3><p>散列表其实是一个稀疏数组（总有空白元素的数组）。我们把散列表里的单元成为表元(bucket)。<br>在 dict 的散列表当中，每个键值对都占用一个表元，每个表元都有两个部分，一个是对键的引用，另一个是对值的引用。因为所有表元的大小一致，所以可以通过偏移量来读取某个表元。<br>因为 Python 会设法保证大概还有三分之一的表元是空的，所以在快要达到这个阈值的时候，原有的散列表会被复制到一个更大的空间里面。<br>如果要把一个对象放入散列表，那么首先要计算这个元素键的散列值。Python 中可以用 <code>hash()</code> 方法来做这件事情</p>
<h4 id="散列值与相等性"><a href="#散列值与相等性" class="headerlink" title="散列值与相等性"></a>散列值与相等性</h4><p>内置的 hash() 方法可以用于所有的内置类型对象。如果是自定义对象调用 hash() 的话，实际上运行的是自定义的 __hash__ 。如果两个对象在比较的时候是相等的，那它们的散列值必须相等，否则散列表就不能正常运行了。<br>为了让散列值能够胜任散列表索引这一角色，它们必须在索引空间中尽量分散开来。这意味着在最理想的状况下，越是相似但不相等的对象，它们散列值的差别应该越大。</p>
<h4 id="散列表算法"><a href="#散列表算法" class="headerlink" title="散列表算法"></a>散列表算法</h4><p>为了获取 <code>my_dict[search_key]</code> 背后的值，Python 首先会调用 <code>hash(search_key)</code> 来计算 search_key 的散列值，把这个值最低的几位数字当作偏移量，在散列表里查找表元（具体取几位，得看当前散列表的大小）。若找到的表元是空的，则抛出 KeyError 异常。若不是空的，则表元里会有一对 <span class="label success">found_key:found_value</span> 。这时候 Python 会检验 <code>search_key == found_key</code> 是否为真，如果它们相等的话，就会返回 found_value。</p>
<p>如果 search_key 和 found_key 不匹配的话，这种情况称为散列冲突。发生这种情况是因为，散列表所做的其实是把随机的元素映射到只有几位的数字上，而散列表本身的索引又只依赖于这个数字的一部分。为了解决散列冲突，算法会在散列值中另外再取几位，然后用特殊的方法处理一下，把新得到的数字再当作索引来寻找表元。若这次找到的表元是空的，则同样抛出 KeyError；若非空，或者键匹配，则返回这个值；或者又发现了散列冲突，则重复以上的步骤。</p>
<img src="/2018/12/17/Python数据结构/从字典中取值的算法流程图.jpg" title="从字典中取值的算法流程图">
<p>另外在插入新值时，Python 可能会按照散列表的拥挤程度来决定是否要重新分配内存为它扩容。如果增加了散列表的大小，那散列值所占的位数和用作索引的位数都会随之增加，这样做的目的是为了 <span class="label success">减少发生散列冲突的概率</span> 。</p>
<p>表面上看，这个算法似乎很费事，而实际上就算 dict 里有数百万个元素，多数的搜索过程中并不会有冲突发生，平均下来每次搜索可能会有一到两次冲突。在正常情况下，就算是最不走运的键所遇到的冲突的次数用一只手也能数过来。</p>
<blockquote>
<p>CPython 的实现细节里有一条是：如果有一个整型对象，而且它能被存进一个机器字中，那么它的散列值就是它本身的值。</p>
</blockquote>
<h3 id="dict-的实现与其导致的结果"><a href="#dict-的实现与其导致的结果" class="headerlink" title="dict 的实现与其导致的结果"></a>dict 的实现与其导致的结果</h3><ol>
<li>key 必须是可散列的，满足以下要求：<ol>
<li>支持 hash() 函数，并且通过 __hash__() 方法得到的 <code>hash值不变</code></li>
<li>支持通过 __eq__() 方法来检测相等性</li>
<li>a == b is hash(a) == hash(b)</li>
</ol>
</li>
<li>字典在内存上的开销极大<br>如果需要存放数量巨大的记录，用 tuple 或者 namedtuple 会节省许多空间，第一是因为避免了散列表消耗的空间，第二是不需要把记录中字段的名字在每个元素里都存一遍</li>
<li>键查询很快</li>
<li>键的次序取决于添加顺序<br>当往 dict 里添加新键而又发生散列冲突的时候，新键可能会被安排存放到另一个位置。于是下面这种情况就会发生：由 dict([key1, value1), (key2, value2)]和 dict([key2, value2], [key1, value1]) 得到的两个字典，在进行比较的时候，它们是相等的；但是如果在 key1 和 key2 被添加到字典里的过程中有冲突发生的话，这两个键出现在字典里的顺序是不一样的。</li>
<li>往字典里添加新键可能会改变已有键的顺序<br>无论何时往字典里添加新的key，Python解释器都可能为字典扩容，扩容导致的结果是要重建一个更大的散列表，所以在迭代一个字典的同时对字典进行修改，那么这个循环很可能会跳过一些键——可能跳过那些字典中已有的键。<br>所以，不要同时对字典进行迭代和修改，如果想扫描并且修改一个字典的内容，可以分为两步进行：<code>先扫描出那些需要修改的键，把这些内容放在一个新字典里，迭代结束之后再对原有的字典进行更新</code></li>
</ol>
<blockquote>
<p>所有由用户自定义的对象默认都是可散列的，因为它们的散列值由 id() 来获取，而且它们都是不相等的。</p>
</blockquote>
<h3 id="set-的实现以及导致的结果"><a href="#set-的实现以及导致的结果" class="headerlink" title="set 的实现以及导致的结果"></a>set 的实现以及导致的结果</h3><p>事实上，set和frozenset的实现也依赖散列表，但在它们的散列表里存放的只有元素的引用。<br>字典的优缺点(查key快，耗内存等)对于集合也适用。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>字典算得上是 Python 的基石。除了基本的 dict 之外，标准库还提供现成且好用的特殊映射类型，比如 defaultdict、OrderedDict、ChainMap 和 Counter。这些映射类型都属于 collections 模块，这个模块还提供了便于扩展的 UserDict 类。</p>
<p>大多数映射类型都提供了两个很强大的方法：setdefault 和 update。setdefault 方法可以用来更新字典里存放的可变值（比如列表），从而避免了重复的键搜索。update 方法则让批量更新成为可能，它可以用来插入新值或者更新已有键值对，它的参数可以是包含 (key, value) 这种键值对的可迭代对象，或者关键字参数。映射类型的构造方法也会利用 update 方法来让用户可以使用别的映射对象、可迭代对象或者关键字参数来创建新对象。</p>
<p>在映射类型的 API 中，有个很好用的方法是 __missing__ ，当对象找不到某个键的时候，可以通过这个方法自定义会发生什么。</p>
<p>collections.abc 模块提供了 Mapping 和 MutableMapping 这两个抽象基类，利用它们，我们可以进行类型查询或者引用。不太为人所知的 MappingProxyType 可以用来创建不可变映射对象，它被封装在 types 模块中。另外还有 Set 和 MutableSet 这两个抽象基类。</p>
<p>dict 和 set 背后的散列表效率很高，对它的了解越深入，就越能理解为什么被保存的元素会呈现出不同的顺序，以及已有的元素顺序会发生变化的原因。同时，速度是以牺牲空间为代价而换来的。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Python/" rel="tag"># Python</a>
          
            <a href="/tags/Model/" rel="tag"># Model</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/14/Python数据模型/" rel="next" title="Python 数据模型">
                <i class="fa fa-chevron-left"></i> Python 数据模型
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/17/Python列表推导/" rel="prev" title="Python列表推导">
                Python列表推导 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Janine">
            
              <p class="site-author-name" itemprop="name">Janine</p>
              <p class="site-description motion-element" itemprop="description">You are my sunshine.</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">16</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#序列类型"><span class="nav-number">1.</span> <span class="nav-text">序列类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#list-comprehension-amp-generator-expression"><span class="nav-number">1.1.</span> <span class="nav-text">list comprehension &amp; generator expression</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关于变量泄露"><span class="nav-number">1.1.1.</span> <span class="nav-text">关于变量泄露</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于元组"><span class="nav-number">1.2.</span> <span class="nav-text">关于元组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#元组拆包"><span class="nav-number">1.2.1.</span> <span class="nav-text">元组拆包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#嵌套元组拆包"><span class="nav-number">1.2.2.</span> <span class="nav-text">嵌套元组拆包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#namedtuple"><span class="nav-number">1.2.3.</span> <span class="nav-text">namedtuple</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作为不可变列表的元组"><span class="nav-number">1.2.4.</span> <span class="nav-text">作为不可变列表的元组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#切片"><span class="nav-number">1.3.</span> <span class="nav-text">切片</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多维切片"><span class="nav-number">1.3.1.</span> <span class="nav-text">多维切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#省略"><span class="nav-number">1.3.2.</span> <span class="nav-text">省略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#序列的-与"><span class="nav-number">1.4.</span> <span class="nav-text">序列的 + 与 *</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#序列的-和"><span class="nav-number">1.5.</span> <span class="nav-text">序列的 += 和 *=</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#list-sort方法和内置函数sorted"><span class="nav-number">1.6.</span> <span class="nav-text">list.sort方法和内置函数sorted</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#当列表不是首选项"><span class="nav-number">1.7.</span> <span class="nav-text">当列表不是首选项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数组"><span class="nav-number">1.7.1.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#memoryview"><span class="nav-number">1.7.2.</span> <span class="nav-text">memoryview</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#队列"><span class="nav-number">1.8.</span> <span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#collections-deque"><span class="nav-number">1.8.1.</span> <span class="nav-text">collections.deque</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#queue"><span class="nav-number">1.8.2.</span> <span class="nav-text">queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#multiprocessing"><span class="nav-number">1.8.3.</span> <span class="nav-text">multiprocessing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#asyncio"><span class="nav-number">1.8.4.</span> <span class="nav-text">asyncio</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#heapq"><span class="nav-number">1.8.5.</span> <span class="nav-text">heapq</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">1.9.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#散列"><span class="nav-number">2.</span> <span class="nav-text">散列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#字典"><span class="nav-number">2.1.</span> <span class="nav-text">字典</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字典创建的不同方式"><span class="nav-number">2.1.1.</span> <span class="nav-text">字典创建的不同方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字典推导"><span class="nav-number">2.1.2.</span> <span class="nav-text">字典推导</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见的映射方法"><span class="nav-number">2.2.</span> <span class="nav-text">常见的映射方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更新值时找不到键的问题"><span class="nav-number">2.3.</span> <span class="nav-text">更新值时找不到键的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一种解决方案–setdefault"><span class="nav-number">2.3.1.</span> <span class="nav-text">一种解决方案–setdefault</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读取映射里不存在的键得到默认值的问题"><span class="nav-number">2.4.</span> <span class="nav-text">读取映射里不存在的键得到默认值的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#defaultdict"><span class="nav-number">2.4.1.</span> <span class="nav-text">defaultdict</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#missing"><span class="nav-number">2.4.2.</span> <span class="nav-text">__missing__</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他映射类型"><span class="nav-number">2.5.</span> <span class="nav-text">其他映射类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编写-UserDict-的子类"><span class="nav-number">2.5.1.</span> <span class="nav-text">编写 UserDict 的子类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不可变映射类型"><span class="nav-number">2.6.</span> <span class="nav-text">不可变映射类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合"><span class="nav-number">2.7.</span> <span class="nav-text">集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dict-和-set-的背后"><span class="nav-number">2.8.</span> <span class="nav-text">dict 和 set 的背后</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dict-中的散列表"><span class="nav-number">2.8.1.</span> <span class="nav-text">dict 中的散列表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#散列值与相等性"><span class="nav-number">2.8.1.1.</span> <span class="nav-text">散列值与相等性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#散列表算法"><span class="nav-number">2.8.1.2.</span> <span class="nav-text">散列表算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dict-的实现与其导致的结果"><span class="nav-number">2.8.2.</span> <span class="nav-text">dict 的实现与其导致的结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set-的实现以及导致的结果"><span class="nav-number">2.8.3.</span> <span class="nav-text">set 的实现以及导致的结果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结-1"><span class="nav-number">2.9.</span> <span class="nav-text">小结</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Janine</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  
  <script src="/js/src/scrollspy.js?v=6.6.0"></script>
<script src="/js/src/post-details.js?v=6.6.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  



  











  





  

  

  

  

  
  

  
  

  


  
  

  

  

  

  

  

  

</body>

<!-- 中英文之间自动添加空格 -->
<script type="text/javascript" src="/js/src/text-autospace.min.js"></script>

</html>
